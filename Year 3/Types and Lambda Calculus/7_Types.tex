\section{Types}

\subsection{Monotypes}

We assume a countable set of type variables $\mb{A}$ (usually
denoted by $a$, $b$, $c$, etc.). The monotypes $\mb{T}$ are a
set of strings defined inductively by the type variable rule:
\begin{align*}
    \frac{}{a \in \mb{T}},
\end{align*} for some $a \in \mb{A}$ and the arrow rule: \begin{align*}
    \frac{A \in T \qquad B \in T}{(A \to B) \in \mb{T}}.
\end{align*}

\subsection{Type Schemes}

Types schemes are pairs consisting of a finite set of type
variables $a_1, \ldots, a_m$ and a monotype $A$ which we
write as $\forall \, a_1 \cdots a_m.A$.

\subsection{Free Type Variables}

We define the set of free type variables for a type scheme
$\forall \, \bar{a}.A$, denoted by
\linebreak $FTV(\forall \, \bar{a}.A)$,
recursively by the following rules: \begin{align*}
    FTV(a) &= \{a\}, \\
    FTV(A \to B) &= FTV(A) \cup FTV(B), \\
    FTV(\forall \, a_1 \cdots a_m.A) &= FTV(A) \backslash \{a_1, \ldots, a_m\}.
\end{align*} We consider type schemes that only differ by choice
of bound variable names to be equivalent.

\subsection{Type Substitution}

A type substitution is a total map $\sigma, \tau, \theta$ 
from $\mb{A}$ to 
$\mb{T}$ with the property that $\sigma(a) \neq a$ for only
finitely many $a \in \mb{A}$. We define the map as follows:
\begin{align*}
    a\sigma &= \sigma(a) \\
    (A \to B)\sigma &= A\sigma \to B\sigma.
\end{align*}

\subsubsection{Composition of Substitutions}

We write $\sigma_1\sigma_2$ for the substitution obtained by
composing $\sigma_2$ after $\sigma_1$, defined as by
$(\sigma_1\sigma_2)(a) = (\sigma_1(a))\sigma_2$.

\subsection{Type Assignment}

A type assignment is a pair of a term $M$ and a type scheme $A$
written $M:A$. The term part is called the subject and the type
part the predicate.

\subsection{Type Environments}

A type environment written $\Gamma$ is a finite set of
type assignments of the form $x : \forall \, \bar{a}.A$
which are consistent in the sense that multiple 
type assignments of the same subject will agree.
\\[\baselineskip]
The subjects of $\Gamma$ is the set $\Dom(\Gamma)$.

\subsection{Type Judgement}

A type judgement is a triple consisting of a type environment $\Gamma$,
a term $M$ and a monotype $A$ written as $\Gamma \vdash M : A$.

\subsection{The Type System}

The type system is defined by the following rules.
For $x : \forall \, \bar{a}.A$ in $\Gamma$ we have the type variable
rule: \begin{align*}
    \frac{}{\Gamma \vdash x : A[\bar{B}/\bar{a}]},
\end{align*} the rule of type application: \begin{align*}
    \frac{
        \Gamma \vdash M : B \to A \qquad \Gamma \vdash N : B
    }{
        \Gamma \vdash MN : A
    },
\end{align*} and for $x$ not in $\Dom(\Gamma)$, we have the rule
of type abstraction: \begin{align*}
    \frac{
        \Gamma \cup \{x : B\} \vdash M : A
    }{
        \Gamma \vdash \lambda x.M : B \to A
    }.
\end{align*} A proof tree justifying a type judgement is called a type
derivation.

\subsection{Typability}

We say a closed term $M$ is typable if there is some type $A$ such that
$\{\} \vdash M : A$. We have that $\lambda x.xx$ is untypable.

\subsection{The Inversion Theorem}

Suppose $\Gamma \vdash M : A$ is derivable, we have that: \begin{itemize}
    \item if $M$ is a variable $x$ then there is a type scheme
        $\forall \, \bar{a}.B$ in $\Gamma$ with $A = B[\bar{C}/\bar{a}]$ 
        for some monotypes $\bar{C}$,
    \item if $M$ is an application $PQ$ then there is a type $B$ such
        that $\Gamma \vdash P : B \to A$ and $\Gamma \vdash Q : B$,
    \item if $M$ is an abstraction $\lambda x.P$ then there are types
        $B$ and $C$ such that $A = B \to C$ and 
        $\Gamma \cup \{x : B\} \vdash P : C$.
\end{itemize}

\subsection{Properties of the System}

For a term $M$, environment $\Gamma$ and type $S$, we
have the following properties.

\paragraph{Subterm Closure}
\leavevmode\newline
If $\Gamma \vdash M : S$ is derivable and $N$ is a subterm
of $M$, there is some $\Gamma'$ containing $\Gamma$ and
some $S'$ such that $\Gamma' \vdash N : S'$. 

\paragraph{Relevance ($1^{\text{st}}$)}
\leavevmode\newline
If $\Gamma \vdash M : S$ then $FV(M) \subseteq \Dom(\Gamma)$.

\paragraph{Relevance ($2^{\text{nd}}$)}
\leavevmode\newline
If $\Gamma \vdash M : S$ then $\{x : A \text{ where }
x : A \in \Gamma \text{ and } x \in FV(M) \} \vdash M : S$.

\paragraph{Weakening}
\leavevmode\newline
If $\Gamma \vdash M : S$ and $\Gamma \subseteq \Gamma'$ then
$\Gamma' \vdash M : S$.

\paragraph{Subject Reduction}
\leavevmode\newline
If $\Gamma \vdash M : A$ and 
$M \to_\beta N$ then $\Gamma \vdash N : A$.

\paragraph{Preservation under Substitution}
\leavevmode\newline
If $\Gamma, x : B \vdash M : A$ and $\Gamma \vdash N : B$
then $\Gamma \vdash M[N / x] : A$.

\paragraph{Subformula}
\leavevmode\newline
We suppose $\Gamma$ has predicates solely consisting of monotypes,
for some term $M$ in $\beta$-normal form with $\Gamma \vdash M : A$
we have that the derivation of this judgement is unique and all
of the types mentioned in the derivation are substrings of types 
mentioned in the conclusion.

\subsection{Type Constraints}

A type constraint is a pair of monotypes $(A, B)$ written
suggestively as $A \teq B$.

\subsection{Constraint Generation}

We create a constraint generating function, which takes in an
environment and a term and returns a pair consisting of a type
variable and a set of constraints: \begin{align*}
    &\text{CGen}(\Gamma, x) = \\
    &\qquad \text{let } a \text{ be fresh} \\
    &\qquad \text{let } \forall \, a_1, \ldots, a_k.A = \Gamma(x) \\
    &\qquad \text{let } b_1, \ldots, b_k \text{ be fresh} \\
    &\qquad (a, \{a \teq A[b_1/a_1, \ldots, b_k/a_k]\}) \\
    \\
    &\text{CGen}(\Gamma, MN) = \\
    &\qquad \text{let } a \text{ be fresh} \\
    &\qquad \text{let } (b, \mc{C}_1) = \text{CGen}(\Gamma, M) \\
    &\qquad \text{let } (c, \mc{C}_2) = \text{CGen}(\Gamma, N) \\
    &\qquad (a, \mc{C}_1 \cup \mc{C}_2 \cup \{b \teq c \to a\}) \\
    \\
    &\text{CGen}(\Gamma, \lambda x.M) = \\
    &\qquad \text{let } a \text{ be fresh} \\
    &\qquad \text{let } b \text{ be fresh} \\
    &\qquad \text{let } (c, \mc{C}) = \text{CGen}(\Gamma \cup \{x : b\}, M) \\
    &\qquad (a, \mc{C} \cup \{a \teq b \to c\})
\end{align*}
