\documentclass[a4paper, 12pt, twoside]{article}
\usepackage[left = 3cm, right = 3cm]{geometry}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{multicol}

\begin{document}

\title{Language Engineering Notes}
\date{}
\author{\textit{paraphrased by} Tyler Wright}
\maketitle

\vfill

\textit{An important note, these notes are absolutely \textbf{NOT}
  guaranteed to be correct, representative of the course, or rigorous.
  Any result of this is not the author's fault.}

\newpage

\section{Syntax and Semantics}

\subsection{What is Syntax?}

Syntax is the grammatical structure of a program. For example,
for the program $x=y;y=z;z=x;$, syntactic analysis of this 
program would conclude that we have three statements concluded
with ';'. Each of said statements are variables followed by
the composite symbol '=' and another variable.

\subsection{What are Semantics?}

The semantics of a program are what the program evaluates
to or rather, the meaning of a syntactically correct program.
For example, $x=y$ evaluates to setting the value of $x$ to the 
value of $y$.

\section{Mathematical Notation}

\subsection{Relations}

For two sets $X, Y$ we have that $f$ is a relation from $X$ to $Y$ if
$f \subseteq X \times Y$.

\subsection{Total Functions}

A total function from $X$ to $Y$ is a function $f : X \to Y$
that maps each value in $X$ to a value in $Y$. 

\subsection{Partial Functions}

A partial function from $X$ to $Y$ is a function 
$f : X \hookrightarrow Y$ where for some $X' \subseteq X$ we have
that $f : X' \to Y$ is total.

\section{The While Language}

\subsection{Syntactic Categories}

For this language, we have five syntactic categories: \begin{itemize}
  \item \textbf{Numerals} (Num), denoted by $n$
  \item \textbf{Variables} (Var), denoted by $x$
  \item \textbf{Arithmetic Expressions} (Aexp), denoted by $a$
  \item \textbf{Boolean Expressions} (Bexp), denoted by $b$
  \item \textbf{Statements} (Stm), denoted by $S$.
\end{itemize} We assume that the numerals and variables are defined
elsewhere (for example, the numerals could be strings of digits
and the variables could be strings of letters). The other
structures are detailed below: \begin{align*}
  a &:= n \, | \, x \, | \, a_1 + a_2 \, | \, a_1 \star a_2 \, | \, a_1 - a_2 \\
  b &:= \texttt{true} \, | \, \texttt{false} \, | \, a_1 == a_2 \, 
  | \, a_1 \leq a_2 \, | \, \neg b \, | \, b_1 \land b_2 \\
  S &:= x = a \, | \, \texttt{skip} \, | \, S_1 ; S_2 \, | \, \texttt{if }
  b \texttt{ then } S_1 \texttt{ else } S_2 \, | \, \texttt{while } 
  b \texttt{ do } S.
\end{align*} We define representations of each structure in terms of itself
as composite elements and the rest are basis elements.

\subsection{State}

When considering a statement, it is almost always important to consider the
state of the program as the role of statements is to change the state
of the program. For example, when evaluating $x + 1$, we must consider
what $x$ is. This requires us to develop the notion of state.
\\[\baselineskip]
We define state as a set of mappings from variables to values: \begin{gather*}
  \textbf{State} = \{f : \textbf{Var} \to \mathbb{Z}\}.
\end{gather*} This is commonly listed out. For example, if $x$ maps to $4$ and 
$y$ maps to $5$, we have our state equal to $\{x \mapsto 4, y \mapsto 5\}$. 

\subsection{Semantic Functions}

The use of semantic functions is to convert syntactic elements into its meaning.
Each of the semantic styles will be used to define said semantic functions
for variable and statements. However, for numerals, arithmetic and boolean
expressions, they are defined as follows. 

\subsubsection{Numerals}

If we assume our numerals are in base-2 (binary), we can define a numeral
as follows: \begin{gather*}
  n := 0 \, | \, 1 \, | \, n \, 0 \, | \, n \, 1 \, |.
\end{gather*} In order to determine the value represented by a numeral, we
define a \textit{semantic function} $\mathcal{N} : \textbf{Num} \to \mathbb{Z}$:
\begin{align*}
  \mathcal{N}(0) &= 0 \\
  \mathcal{N}(1) &= 1 \\
  \mathcal{N}(n \, 0) &= 2 \cdot \mathcal{N}(n) \\
  \mathcal{N}(n \, 1) &= 2 \cdot \mathcal{N}(n) + 1 \\
\end{align*} This definition is called \textit{compositional} as it simply
defines an output for each way of constructing a numeral.
\\[\baselineskip]
\textit{Much like Linear Algebra, it is important to differentiate
the numeral '1' and the integer $1$ and similarly for zero.}

\subsubsection{Arithmetic Expressions}

For a given arithmetic expression, it may be necessary to analyse the state
to determine the result. Thus, the semantic expression for arithmetic
expressions is a function $\mathcal{A} : \textbf{Aexp} \to (\textbf{State} 
\to \mathbb{Z})$. 
\\[\baselineskip]
This means providing $\mathcal{A}$ with an arithmetic
expression gives us a function from a state to a value. So, for a state $s$,
we can define $\mathcal{A}$ as follows: \begin{align*}
  \mathcal{A}(n)(s) &= \mathcal{N}(n) \\
  \mathcal{A}(x)(s) &= s(x) \\
  \mathcal{A}(a_1 + a_2)(s) &= \mathcal{A}(a_1)(s) + \mathcal{A}(a_2)(s) \\
  \mathcal{A}(a_1 \star a_2)(s) &= \mathcal{A}(a_1)(s) \star \mathcal{A}(a_2)(s) \\
  \mathcal{A}(a_1 - a_2)(s) &= \mathcal{A}(a_1)(s) - \mathcal{A}(a_2)(s).
\end{align*} Similarly to the numerical semantic function, it's important
to differentiate between the syntactic $+, \star, -$ in the arithmetic
expressions like $a_1 + a_2$ and the usual arithmetic operations $+, \star, -$
between integers.

\subsubsection{Boolean Expressions}

We define the set $T$ to be $T = \{\text{tt}, \text{ff}\}$ where tt represents
truth and ff represents falsity.
\\[\baselineskip]
Similarly to arithmetic expressions we can define $\mathcal{B} : \textbf{Bexp}
\to (\textbf{State} \to \mathbb{Z})$ for a state $s$: \begin{align*}
  \mathcal{B}(\texttt{true})(s) &= \text{tt} \\
  \mathcal{B}(\texttt{false})(s) &= \text{ff} \\
  \mathcal{B}(a_1 == a_2)(s) &= \begin{cases}
      \text{tt} & \text{if } \mathcal{A}(a_1)(s) = \mathcal{A}(a_2)(s) \\
      \text{ff} & \text{otherwise}
  \end{cases} \\
  \mathcal{B}(a_1 \leq a_2)(s) &= \begin{cases}
    \text{tt} & \text{if } \mathcal{A}(a_1)(s) \leq \mathcal{A}(a_2)(s) \\
    \text{ff} & \text{if } \mathcal{A}(a_1)(s) > \mathcal{A}(a_2)(s)
  \end{cases} \\
  \mathcal{B}(\neg b)(s) &= \begin{cases}
    \text{tt} & \text{if } \mathcal{B}(b)(s) = \text{ff} \\
    \text{ff} & \text{if } \mathcal{B}(b)(s) = \text{tt}
  \end{cases} \\
  \mathcal{B}(b_1 \land b_2)(s) &= \begin{cases}
    \text{tt} & \text{if } \mathcal{B}(b_1)(s) = \text{tt} \text{ and } \mathcal{B}(b_2)(s) = \text{tt} \\
    \text{ff} & \text{if } \mathcal{B}(b_1)(s) = \text{ff} \text{ or } \mathcal{B}(b_2)(s) = \text{ff} \\
  \end{cases}
\end{align*}

\subsection{Free Variables}

We will later be interested in the 'free variables' of an expression 
(the set of variables occuring within it).

\subsubsection{Arithmetic Expressions}

We define $F_V : \textbf{Aexp} \to \{\textbf{Var}\}$ by: \begin{align*}
  F_V(n) &:= \emptyset \\
  F_V(x) &:= \{x\} \\
  F_V(a_1 + a_2) &:= F_V(a_1) \cup F_V(a_2) \\
  F_V(a_1 \star a_2) &:= F_V(a_1) \cup F_V(a_2) \\
  F_V(a_1 - a_2) &:= F_V(a_1) \cup F_V(a_2).
\end{align*} Thus, we have developed a way to decompose expressions
and generate all the variables said expression depends on. This
is formalised for states $s_1, s_2$ and an arithmetic expression 
$a$: \begin{gather*}
  [\forall x \in F_V(a)][s_1(x) = s_2(x)] \Longrightarrow 
  [\mathcal{A}(a)(s_1) = \mathcal{A}(a)(s_2)].
\end{gather*}

\subsubsection{Boolean Expressions}

We define $F_V : \textbf{Bexp} \to \{\textbf{Var}\}$ by: \begin{align*}
  F_V(\texttt{true}) &:= \emptyset \\
  F_V(\texttt{false}) &:= \emptyset \\
  F_V(a_1 == a_2) &:= F_V(a_1) \cup F_V(a_2) \\
  F_V(a_1 \leq a_2) &:= F_V(a_1) \cup F_V(a_2) \\
  F_V(\neg b) &:= F_V(b) \\
  F_V(b_1 \land b_2) &:= F_V(b_1) \cup F_V(b_2).
\end{align*} Similarly, for states $s_1, s_2$ and an boolean expression 
$b$: \begin{gather*}
  [\forall x \in F_V(b)][s_1(x) = s_2(x)] \Longrightarrow 
  [\mathcal{B}(b)(s_1) = \mathcal{B}(b)(s_2)].
\end{gather*}

\newpage

\subsection{Substitutions}

Within expressions, we will be interested in swapping the occurances
of a variable with another expression. For an expression $e$ with
$x$ in $F_V(e)$ and another expression $e_0$, we write
$e[x\mapsto e_0]$ for the expression $e$ where $x$ is substituted
for $e_0$.

\subsubsection{Arithmetic Expressions}

For an arithmetic expression $a_0$, we can define substitution on
arithmetic expressions: \begin{align*}
  n[y \mapsto a_0] &:= n \\
  x[y \mapsto a_0] &:= \begin{cases}
    a_0 & \text{if } x = y \\
    x & \text{otherwise}
  \end{cases} \\
  (a_1 + a_2)[y \mapsto a_0] &:= (a_1[y \mapsto a_0]) + (a_2[y \mapsto a_0]) \\
  (a_1 \star a_2)[y \mapsto a_0] &:= (a_1[y \mapsto a_0]) \star (a_2[y \mapsto a_0]) \\
  (a_1 - a_2)[y \mapsto a_0] &:= (a_1[y \mapsto a_0]) - (a_2[y \mapsto a_0]).
\end{align*}

\subsubsection{Boolean Expressions}

For an arithmetic expression $a_0$, we can define substitution on 
boolean expressions: \begin{align*}
  (\texttt{true})[x \mapsto a_0] &:= \texttt{true} \\
  (\texttt{false})[x \mapsto a_0] &:=  \texttt{false} \\
  (a_1 == a_2)[x \mapsto a_0] &:= (a_1[x \mapsto a_0]) == (a_2[x \mapsto a_0])\\
  (a_1 \leq a_2)[x \mapsto a_0] &:= (a_1[x \mapsto a_0]) \leq (a_2[x \mapsto a_0]) \\
  (\neg b)[x \mapsto a_0] &:= \neg (b)[x \mapsto a_0] \\
  (b_1 \land b_2)[x \mapsto a_0] &:= (b_1)[x \mapsto a_0] \land (b_2)[x \mapsto a_0].
\end{align*}

\subsubsection{States}

A similar process applies to states, for a state $s$ and the variables
$x, v$: \begin{gather*}
  (s[y\mapsto v])(x) = \begin{cases}
    v & \text{if } x = y \\
    s(x) & \text{otherwise}.
  \end{cases}
\end{gather*}

\newpage

\section{Operational Semantics}

\subsection{Overview of Operational Semantics}

An operational explanation of the meaning of a construct will explain
how to execute said construct. For example, in C, the semicolons provide
chronology and the $=$ symbol demonstrates assignment. The semantics
are not merely interested in the results of a program.
\\[\baselineskip]
More specifically, this means we are interested in how the state of the
program changes. To this end, there are two approaches we shall consider:
\begin{itemize}
  \item \textbf{Natural Semantics}: to describe how the overall
  results of executions are obtained
  \item \textbf{Structural Operational Semantics}: to describe how
  the individual steps of computation take place.
\end{itemize} During this section, we will use $\langle S, s\rangle$
representing the statement $S$ being executed from the state $s$ and
simply $s$ to represent a terminal state.

\subsection{Rules and Derivation Trees}

\subsubsection{Transitions}

A transition is a construct representing the transition of
a state $s$ to a state $s'$ via some statement $S$, denoted
by $\langle S, s \rangle \to s'$.

\subsubsection{Rules}

We can define 'rules' which are of the form: \begin{gather*}
  \frac{
    \langle S_1, s_1 \rangle \to s_2, \ldots, \langle S_n, s_n \rangle \to s'
  }{
    \langle S, s \rangle \to s'
  } \qquad \text{if } \cdots.
\end{gather*} Where the premises consisting of immediate constituents 
of a statement $S$ or compositions of said immediate constituents, 
are written above the conclusion. Conditions may be written to the right
of the rule which are necessary for when the rule is applied.

\subsubsection{Axioms}

For a rule where the set of premises is empty, we call 
such a rule an \textit{axiom}. Axioms with meta-variables
are called \textit{axiom schema} where we can obtain an
\textit{instance} of an axiom by defining particular
variables.

\subsubsection{Derivation Trees}

A program's execution can be modelled by a 'derivation tree'
formed from rules.
For example, the program $x=y;y=z;z=x;$ can be written as:
\begin{gather*}
  \frac{\dfrac{
    \langle z=x, s_{570} \rangle \to s_{575} 
    \qquad \langle x=y, s_{575} \rangle \to s_{775}
  }{\langle z=x;x=y, s_{570} \rangle \to s_{775}}
  \qquad \langle y=z, s_{775} \rangle \to s_{755}}
  {\langle x=y;y=z;z=x, s_{570} \rangle \to s_{755}}.
\end{gather*} Where $s_{abc}$ represents the state where 
$\{x \mapsto a, y \mapsto b, z \mapsto c\}$.
\\[\baselineskip]
This tree repesents the decomposition of the composite statement
at the bottom of the tree $x=y;y=z;z=x;$. As $z=x$ transforms
the state $s_{570}$ to $s_{575}$ and $x=y$ transforms the state
$s_{575}$ to $s_{775}$, we know that the composite statement
$z=x;x=y$ transforms $s_{570}$ to $s_{775}$.

\subsubsection{Natural Semantics}

We can define some natural semantics for the While language as follows:
\begin{align*}
  [\text{assignment}]& \qquad \langle x=a, s \rangle \to s[x\mapsto \mathcal{A}(a)(s)] \\ \\
  [\text{skip}]& \qquad \langle \texttt{skip}, s \rangle \to s \\ \\
  [\text{composition}]& \qquad \frac{
    \langle S_1, s \rangle \to s' \qquad \langle S_2, s' \rangle \to s''
  }{\langle S_1;S_2, s \rangle \to s''} \\ \\
  [\text{if}]& \qquad \begin{cases}
    \dfrac{
      \langle S_1, s \rangle \to s'
    }{
      \langle \texttt{if } b \texttt{ then } S_1 \texttt{ else } S_2, s \rangle \to s'
    } & \text{if } \mathcal{B}(b)(s) = \text{tt} \\ \\
    \dfrac{
      \langle S_2, s \rangle \to s'
    }{
      \langle \texttt{if } b \texttt{ then } S_1 \texttt{ else } S_2, s \rangle \to s'
    } & \text{if } \mathcal{B}(b)(s) = \text{ff}
  \end{cases} \\ \\
  [\text{while}]& \qquad \begin{cases}
    \dfrac{
      \langle S, s \rangle \to s' \qquad \langle 
      \texttt{while } b \texttt{ do } S, s' \rangle \to s''
    }{
      \langle \texttt{while } b \texttt{ do } S, s \rangle \to s''
    } & \text{if } \mathcal{B}(b)(s) = \text{tt} \\ \\
    \langle \texttt{while } b \texttt{ do } S, s \rangle \to s
    & \text{if } \mathcal{B}(b)(s) = \text{ff}
  \end{cases}
\end{align*}

\end{document}