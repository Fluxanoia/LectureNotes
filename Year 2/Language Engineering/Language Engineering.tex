\documentclass[a4paper, 12pt, twoside]{article}
\usepackage[left = 3cm, right = 3cm]{geometry}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{multicol}
\usepackage{multirow}
\usepackage{arydshln}

\usepackage{listings}
\usepackage{color}

\lstset{frame=none,
  language=Haskell,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=2
}

\begin{document}

\title{Language Engineering Notes}
\date{}
\author{\textit{paraphrased by} Tyler Wright}
\maketitle

\vfill

\textit{An important note, these notes are absolutely \textbf{NOT}
  guaranteed to be correct, representative of the course, or rigorous.
  Any result of this is not the author's fault.}

\newpage

\section{Syntax and Semantics}

\subsection{What is Syntax?}

Syntax is the grammatical structure of a program. For example,
for the program $x=y;y=z;z=x;$, syntactic analysis of this 
program would conclude that we have three statements concluded
with ';'. Each of said statements are variables followed by
the composite symbol '=' and another variable.

\subsection{What are Semantics?}

The semantics of a program are what the program evaluates
to or rather, the meaning of a syntactically correct program.
For example, $x=y$ evaluates to setting the value of $x$ to the 
value of $y$.

\section{Mathematical Notation}

\subsection{Relations}

For two sets $X, Y$ we have that $f$ is a relation from $X$ to $Y$ if
$f \subseteq X \times Y$.

\subsection{Total Functions}

A total function from $X$ to $Y$ is a function $f : X \to Y$
that maps each value in $X$ to a value in $Y$. 

\subsection{Partial Functions}

A partial function from $X$ to $Y$ is a function 
$f : X \hookrightarrow Y$ where for some $X' \subseteq X$ we have
that $f : X' \to Y$ is total.

\newpage

\section{The While Language}

\subsection{Syntactic Categories}

For this language, we have five syntactic categories: \begin{itemize}
  \item \textbf{Numerals} (Num), denoted by $n$
  \item \textbf{Variables} (Var), denoted by $x$
  \item \textbf{Arithmetic Expressions} (Aexp), denoted by $a$
  \item \textbf{Boolean Expressions} (Bexp), denoted by $b$
  \item \textbf{Statements} (Stm), denoted by $S$.
\end{itemize} We assume that the numerals and variables are defined
elsewhere (for example, the numerals could be strings of digits
and the variables could be strings of letters). The other
structures are detailed below: \begin{align*}
  a &:= n \, | \, x \, | \, a_1 + a_2 \, | \, a_1 \star a_2 \, | \, a_1 - a_2 \\
  b &:= \texttt{true} \, | \, \texttt{false} \, | \, a_1 == a_2 \, 
  | \, a_1 \leq a_2 \, | \, \neg b \, | \, b_1 \land b_2 \\
  S &:= x = a \, | \, \texttt{skip} \, | \, S_1 ; S_2 \, | \, \texttt{if }
  b \texttt{ then } S_1 \texttt{ else } S_2 \, | \, \texttt{while } 
  b \texttt{ do } S.
\end{align*} We define representations of each structure in terms of itself
as composite elements and the rest are basis elements.

\subsubsection{Extensions of the categories}

We define a language \textbf{Exc} identical to \textbf{While} except we
extend the \textbf{Statements} to: \begin{align*}
  S &:= x = a \, | \, \texttt{skip} \, | \, S_1 ; S_2 \, | \, \texttt{if }
  b \texttt{ then } S_1 \texttt{ else } S_2 \, | \, \texttt{while } 
  b \texttt{ do } S \\
  & \qquad \texttt{begin } S_1 \texttt{ handle } e : S_2 \texttt{ end} \, |
  \, \texttt{raise } e,
\end{align*} and we define the \textbf{Exception} of which $e$ is a member of.
\\[\baselineskip]
The \texttt{raise} instruction, when called, breaks the execution of
the current statement and gives control to the handling statement.

\subsection{State}

When considering a statement, it is almost always important to consider the
state of the program as the role of statements is to change the state
of the program. For example, when evaluating $x + 1$, we must consider
what $x$ is. This requires us to develop the notion of state.
\\[\baselineskip]
We define state as a set of mappings from variables to values: \begin{gather*}
  \textbf{State} = \{f : \textbf{Var} \to \mathbb{Z}\}.
\end{gather*} This is commonly listed out. For example, if $x$ maps to $4$ and 
$y$ maps to $5$, we have our state equal to $\{x \mapsto 4, y \mapsto 5\}$. 

\subsection{Semantic Functions}

The use of semantic functions is to convert syntactic elements into its meaning.
Each of the semantic styles will be used to define said semantic functions
for variable and statements. However, for numerals, arithmetic and boolean
expressions, they are defined as follows. 

\subsubsection{Numerals}

If we assume our numerals are in base-2 (binary), we can define a numeral
as follows: \begin{gather*}
  n := 0 \, | \, 1 \, | \, n \, 0 \, | \, n \, 1 \, |.
\end{gather*} In order to determine the value represented by a numeral, we
define a \textit{semantic function} $\mathcal{N} : \textbf{Num} \to \mathbb{Z}$:
\begin{align*}
  \mathcal{N}(0) &= 0 \\
  \mathcal{N}(1) &= 1 \\
  \mathcal{N}(n \, 0) &= 2 \cdot \mathcal{N}(n) \\
  \mathcal{N}(n \, 1) &= 2 \cdot \mathcal{N}(n) + 1 \\
\end{align*} This definition is called \textit{compositional} as it simply
defines an output for each way of constructing a numeral.
\\[\baselineskip]
\textit{Much like Linear Algebra, it is important to differentiate
the numeral '1' and the integer $1$ and similarly for zero.}

\subsubsection{Arithmetic Expressions}

For a given arithmetic expression, it may be necessary to analyse the state
to determine the result. Thus, the semantic expression for arithmetic
expressions is a function $\mathcal{A} : \textbf{Aexp} \to (\textbf{State} 
\to \mathbb{Z})$. 
\\[\baselineskip]
This means providing $\mathcal{A}$ with an arithmetic
expression gives us a function from a state to a value. So, for a state $s$,
we can define $\mathcal{A}$ as follows: \begin{align*}
  \mathcal{A}(n)(s) &= \mathcal{N}(n) \\
  \mathcal{A}(x)(s) &= s(x) \\
  \mathcal{A}(a_1 + a_2)(s) &= \mathcal{A}(a_1)(s) + \mathcal{A}(a_2)(s) \\
  \mathcal{A}(a_1 \star a_2)(s) &= \mathcal{A}(a_1)(s) \star \mathcal{A}(a_2)(s) \\
  \mathcal{A}(a_1 - a_2)(s) &= \mathcal{A}(a_1)(s) - \mathcal{A}(a_2)(s).
\end{align*} Similarly to the numerical semantic function, it's important
to differentiate between the syntactic $+, \star, -$ in the arithmetic
expressions like $a_1 + a_2$ and the usual arithmetic operations $+, \star, -$
between integers.

\subsubsection{Boolean Expressions}

We define the set $T$ to be $T = \{\text{tt}, \text{ff}\}$ where tt represents
truth and ff represents falsity.
\\[\baselineskip]
Similarly to arithmetic expressions we can define $\mathcal{B} : \textbf{Bexp}
\to (\textbf{State} \to \mathbb{Z})$ for a state $s$: \begin{align*}
  \mathcal{B}(\texttt{true})(s) &= \text{tt} \\
  \mathcal{B}(\texttt{false})(s) &= \text{ff} \\
  \mathcal{B}(a_1 == a_2)(s) &= \begin{cases}
      \text{tt} & \text{if } \mathcal{A}(a_1)(s) = \mathcal{A}(a_2)(s) \\
      \text{ff} & \text{otherwise}
  \end{cases} \\
  \mathcal{B}(a_1 \leq a_2)(s) &= \begin{cases}
    \text{tt} & \text{if } \mathcal{A}(a_1)(s) \leq \mathcal{A}(a_2)(s) \\
    \text{ff} & \text{if } \mathcal{A}(a_1)(s) > \mathcal{A}(a_2)(s)
  \end{cases} \\
  \mathcal{B}(\neg b)(s) &= \begin{cases}
    \text{tt} & \text{if } \mathcal{B}(b)(s) = \text{ff} \\
    \text{ff} & \text{if } \mathcal{B}(b)(s) = \text{tt}
  \end{cases} \\
  \mathcal{B}(b_1 \land b_2)(s) &= \begin{cases}
    \text{tt} & \text{if } \mathcal{B}(b_1)(s) = \text{tt} \text{ and } \mathcal{B}(b_2)(s) = \text{tt} \\
    \text{ff} & \text{if } \mathcal{B}(b_1)(s) = \text{ff} \text{ or } \mathcal{B}(b_2)(s) = \text{ff} \\
  \end{cases}
\end{align*}

\subsection{Free Variables}

We will later be interested in the 'free variables' of an expression 
(the set of variables occuring within it).

\subsubsection{Arithmetic Expressions}

We define $F_V : \textbf{Aexp} \to \{\textbf{Var}\}$ by: \begin{align*}
  F_V(n) &:= \emptyset \\
  F_V(x) &:= \{x\} \\
  F_V(a_1 + a_2) &:= F_V(a_1) \cup F_V(a_2) \\
  F_V(a_1 \star a_2) &:= F_V(a_1) \cup F_V(a_2) \\
  F_V(a_1 - a_2) &:= F_V(a_1) \cup F_V(a_2).
\end{align*} Thus, we have developed a way to decompose expressions
and generate all the variables said expression depends on. This
is formalised for states $s_1, s_2$ and an arithmetic expression 
$a$: \begin{gather*}
  [\forall x \in F_V(a)][s_1(x) = s_2(x)] \Longrightarrow 
  [\mathcal{A}(a)(s_1) = \mathcal{A}(a)(s_2)].
\end{gather*}

\subsubsection{Boolean Expressions}

We define $F_V : \textbf{Bexp} \to \{\textbf{Var}\}$ by: \begin{align*}
  F_V(\texttt{true}) &:= \emptyset \\
  F_V(\texttt{false}) &:= \emptyset \\
  F_V(a_1 == a_2) &:= F_V(a_1) \cup F_V(a_2) \\
  F_V(a_1 \leq a_2) &:= F_V(a_1) \cup F_V(a_2) \\
  F_V(\neg b) &:= F_V(b) \\
  F_V(b_1 \land b_2) &:= F_V(b_1) \cup F_V(b_2).
\end{align*} Similarly, for states $s_1, s_2$ and an boolean expression 
$b$: \begin{gather*}
  [\forall x \in F_V(b)][s_1(x) = s_2(x)] \Longrightarrow 
  [\mathcal{B}(b)(s_1) = \mathcal{B}(b)(s_2)].
\end{gather*}

\newpage

\subsection{Substitutions}

Within expressions, we will be interested in swapping the occurances
of a variable with another expression. For an expression $e$ with
$x$ in $F_V(e)$ and another expression $e_0$, we write
$e[x\mapsto e_0]$ for the expression $e$ where $x$ is substituted
for $e_0$.

\subsubsection{Arithmetic Expressions}

For an arithmetic expression $a_0$, we can define substitution on
arithmetic expressions: \begin{align*}
  n[y \mapsto a_0] &:= n \\
  x[y \mapsto a_0] &:= \begin{cases}
    a_0 & \text{if } x = y \\
    x & \text{otherwise}
  \end{cases} \\
  (a_1 + a_2)[y \mapsto a_0] &:= (a_1[y \mapsto a_0]) + (a_2[y \mapsto a_0]) \\
  (a_1 \star a_2)[y \mapsto a_0] &:= (a_1[y \mapsto a_0]) \star (a_2[y \mapsto a_0]) \\
  (a_1 - a_2)[y \mapsto a_0] &:= (a_1[y \mapsto a_0]) - (a_2[y \mapsto a_0]).
\end{align*}

\subsubsection{Boolean Expressions}

For an arithmetic expression $a_0$, we can define substitution on 
boolean expressions: \begin{align*}
  (\texttt{true})[x \mapsto a_0] &:= \texttt{true} \\
  (\texttt{false})[x \mapsto a_0] &:=  \texttt{false} \\
  (a_1 == a_2)[x \mapsto a_0] &:= (a_1[x \mapsto a_0]) == (a_2[x \mapsto a_0])\\
  (a_1 \leq a_2)[x \mapsto a_0] &:= (a_1[x \mapsto a_0]) \leq (a_2[x \mapsto a_0]) \\
  (\neg b)[x \mapsto a_0] &:= \neg (b)[x \mapsto a_0] \\
  (b_1 \land b_2)[x \mapsto a_0] &:= (b_1)[x \mapsto a_0] \land (b_2)[x \mapsto a_0].
\end{align*}

\subsubsection{States}

A similar process applies to states, for a state $s$ and the variables
$x, v$: \begin{gather*}
  (s[y\mapsto v])(x) = \begin{cases}
    v & \text{if } x = y \\
    s(x) & \text{otherwise}.
  \end{cases}
\end{gather*}

\newpage

\section{Operational Semantics}

\subsection{Overview of Operational Semantics}

An operational explanation of the meaning of a construct will explain
how to execute said construct. For example, in C, the semicolons provide
chronology and the $=$ symbol demonstrates assignment. The semantics
are not merely interested in the results of a program.
\\[\baselineskip]
More specifically, this means we are interested in how the state of the
program changes. To this end, there are two approaches we shall consider:
\begin{itemize}
  \item \textbf{Natural Semantics}: to describe how the overall
  results of executions are obtained
  \item \textbf{Structural Operational Semantics}: to describe how
  the individual steps of computation take place.
\end{itemize}

\subsection{Rules and Derivation Trees}

\subsubsection{Transitions}

A transition is a construct representing the transition of
a state $s$ to a state $s'$ via some statement $S$, denoted
by $\langle S, s \rangle \to s'$.

\subsubsection{Rules}

We can define 'rules' which are of the form: \begin{gather*}
  \frac{
    \langle S_1, s_1 \rangle \to s_2, \ldots, \langle S_n, s_n \rangle \to s'
  }{
    \langle S, s \rangle \to s'
  } \qquad \text{if } \cdots.
\end{gather*} Where the premises consisting of immediate constituents 
of a statement $S$ or compositions of said immediate constituents, 
are written above the conclusion. Conditions may be written to the right
of the rule which are necessary for when the rule is applied.

\subsubsection{Axioms}

For a rule where the set of premises is empty, we call 
such a rule an \textit{axiom}. Axioms with meta-variables
are called \textit{axiom schema} where we can obtain an
\textit{instance} of an axiom by defining particular
variables.

\subsubsection{Derivation Trees}

A program's execution can be modelled by a 'derivation tree'
formed from rules.
For example, the program $x=y;y=z;z=x;$ can be written as:
\begin{gather*}
  \frac{\dfrac{
    \langle z=x, s_{570} \rangle \to s_{575} 
    \qquad \langle x=y, s_{575} \rangle \to s_{775}
  }{\langle z=x;x=y, s_{570} \rangle \to s_{775}}
  \qquad \langle y=z, s_{775} \rangle \to s_{755}}
  {\langle x=y;y=z;z=x, s_{570} \rangle \to s_{755}}.
\end{gather*} Where $s_{abc}$ represents the state where 
$\{x \mapsto a, y \mapsto b, z \mapsto c\}$.
\\[\baselineskip]
This tree repesents the decomposition of the composite statement
at the bottom of the tree $x=y;y=z;z=x;$. As $z=x$ transforms
the state $s_{570}$ to $s_{575}$ and $x=y$ transforms the state
$s_{575}$ to $s_{775}$, we know that the composite statement
$z=x;x=y$ transforms $s_{570}$ to $s_{775}$.

\subsection{Natural Semantics}

During this section, we will use $\langle S, s\rangle$
representing the statement $S$ being executed from the state $s$ and
simply $s$ to represent a terminal state.
\\[\baselineskip]
We can define some natural semantics for the While language as follows:
\begin{align*}
  [\text{assignment}]& \qquad \langle x=a, s \rangle \to s[x\mapsto \mathcal{A}(a)(s)] \\ \\
  [\text{skip}]& \qquad \langle \texttt{skip}, s \rangle \to s \\ \\
  [\text{composition}]& \qquad \frac{
    \langle S_1, s \rangle \to s' \qquad \langle S_2, s' \rangle \to s''
  }{\langle S_1;S_2, s \rangle \to s''} \\ \\
  [\text{if}]& \qquad \begin{cases}
    \dfrac{
      \langle S_1, s \rangle \to s'
    }{
      \langle \texttt{if } b \texttt{ then } S_1 \texttt{ else } S_2, s \rangle \to s'
    } & \text{if } \mathcal{B}(b)(s) = \text{tt} \\ \\
    \dfrac{
      \langle S_2, s \rangle \to s'
    }{
      \langle \texttt{if } b \texttt{ then } S_1 \texttt{ else } S_2, s \rangle \to s'
    } & \text{if } \mathcal{B}(b)(s) = \text{ff}
  \end{cases} \\ \\
  [\text{while}]& \qquad \begin{cases}
    \dfrac{
      \langle S, s \rangle \to s' \qquad \langle 
      \texttt{while } b \texttt{ do } S, s' \rangle \to s''
    }{
      \langle \texttt{while } b \texttt{ do } S, s \rangle \to s''
    } & \text{if } \mathcal{B}(b)(s) = \text{tt} \\ \\
    \langle \texttt{while } b \texttt{ do } S, s \rangle \to s
    & \text{if } \mathcal{B}(b)(s) = \text{ff}
  \end{cases}
\end{align*}

We have that the semantics detailed above are deterministic, that is,
for identical inputs, we get identical outputs.
\\[\baselineskip]
As there is more than one definition of these semantics
we will subscript these defintions with $ns$ where appropriate.

\subsubsection{The Semantic Function}

We can now condense the meaning of statements into a partial
function from \textbf{State} to \textbf{State}. We define the semantic
function as follows: \begin{gather*}
  \mathcal{S}: \textbf{Stm} \to (\textbf{State} \hookrightarrow \textbf{State}).
\end{gather*} Thus for a given statement $S$, we have that: \begin{align*}
  &\mathcal{S}(S) : \textbf{State} \hookrightarrow \textbf{State} \\
  s &\mapsto \begin{cases}
    s' & \text{if } \langle S, s \rangle \to s' \\
    \text{undefined} & \text{otherwise}.
  \end{cases}
\end{align*} We that this function is partial because some statements
may never terminate. Thus giving an indeterminate answer.
\\[\baselineskip]
As there will be more than one semantic function (for our different types
of semantics) we denote this function as $\mathcal{S}_{ns}$.

\subsection{Structural Operational Semantics}

In structural operation semantics, there is a particular emphasis
on the individual steps of execution. The transition relation in
these semantics is of the form: \begin{gather*}
  \langle S, s \rangle \Rightarrow \gamma,
\end{gather*} where $\gamma$ is of the form:
\begin{center}
\renewcommand{\arraystretch}{1.5}
\begin{tabular}{ | c || p{8.5cm} | }
  \hline
  $\langle S', s' \rangle$ & denoting that $S$ and $s$
  have transformed in some way and that the execution is not
  yet complete, \\
  $s'$ & denoting that the execution has completed with some 
  terminal state $s'$. \\
  \hline
\end{tabular}
\end{center}

\noindent
We shall say that $\langle S, s \rangle$ is \textbf{stuck} if there
does not exist a $\gamma$ such that $\langle S, s \rangle
\Rightarrow \gamma$ and \textbf{unstuck} otherwise. 

\newpage

We can define some structural operational semantics for the While 
language as follows:
\begin{align*}
  [\text{assignment}]& \qquad \langle x=a, s \rangle \Rightarrow s[x\mapsto \mathcal{A}(a)(s)] \\ \\
  [\text{skip}]& \qquad \langle \texttt{skip}, s \rangle \Rightarrow s \\ \\
  [\text{composition}]& \qquad \frac{
    \langle S_1, s \rangle \Rightarrow \langle S'_1, s' \rangle
  }{\langle S_1;S_2, s \rangle \Rightarrow \langle S'_1;S_2, s' \rangle} 
  \qquad \text{or} \qquad \frac{
    \langle S_1, s \rangle \Rightarrow s'
  }{\langle S_1;S_2, s \rangle \Rightarrow \langle S_2, s' \rangle} \\ \\
  [\text{if}]& \qquad \begin{cases}
    \langle \texttt{if } b \texttt{ then } S_1 \texttt{ else } S_2, s \rangle \Rightarrow 
    \langle S_1, s \rangle
    & \text{if } \mathcal{B}(b)(s) = \text{tt} \\ \\
    \langle \texttt{if } b \texttt{ then } S_1 \texttt{ else } S_2, s \rangle \Rightarrow
    \langle S_2, s \rangle
    & \text{if } \mathcal{B}(b)(s) = \text{ff}
  \end{cases} \\ \\
  [\text{while}]& \qquad \langle \texttt{while } b \texttt{ do } S, s \rangle \Rightarrow
    \langle \texttt{if } b \texttt{ then } (S; \texttt{ while } b \texttt{ do } S)
    \texttt{ else skip}, s \rangle
\end{align*}

We can see by the definition of composition that with these 
semantics we have to fully decompose and execution $S_1$ before
we can begin execution of $S_2$.
\\[\baselineskip]
As there is more than one definition of these semantics
we will subscript these defintions with $sos$ where appropriate.

\subsubsection{Derivation Sequences}

For a statement $S$ and state $s$, we can consider the sequence of
configurations of $S$ in $s$. The length of such a sequence is either:
\begin{itemize}
  \item \textbf{Finite}: $\gamma_0, \gamma_1, \gamma_2, \ldots, \gamma_k$
  for some $k$ in $\mathbb{Z}_{\geq 0}$ where each $i$ in $\{0, 1, \ldots, k - 1\}$ satisfies
  $\gamma_0 = \langle S, s \rangle$, $\gamma_i \Rightarrow \gamma_{i + 1}$ where
  $\gamma_k$ is terminal or stuck
  \item \textbf{Infinite}: $(\gamma_k)_{k \geq 0}$ where 
  for each $i$ in $\mathbb{Z}_{\geq 0}$ satisfies 
  $\gamma_0 = \langle S, s \rangle$, $\gamma_i \Rightarrow \gamma_{i + 1}$.
\end{itemize} For two configurations $\gamma_i, \gamma_k$, we write
$\gamma_i \Rightarrow^k \gamma_j$ to denote that there are $k$ steps 
in execution between the configurations or $\gamma_i \Rightarrow^* \gamma_j$
to denote that there's some finite number of steps between the two
configurations.

\newpage

We say for a statement $S$ and state $s$, the execution of $S$ on $s$:
\begin{itemize}
  \item \textbf{Terminates}: if and only if there's a finite derivation
  sequence starting with $\langle S, s, \rangle$
  \item \textbf{Loops}: if and only if there's a infinite derivation
  sequence starting with $\langle S, s \rangle$.
\end{itemize} Thus, statements can loop on some states and terminate on
others. Similarly, some states always terminate and always loop.

\subsubsection{Partial Execution}

If for some statement $S$, $k$ in $\mathbb{Z}_{\geq 0}$, and states 
$s, s''$, we have that $\langle S, s\rangle \Rightarrow^k s''$,
then there exists $k_1, k_2$ in $\mathbb{Z}_{\geq 0}$ such that 
$k_1 + k_2 = k$, $\langle S, s \rangle \Rightarrow^{k_1} s'$,
and $\langle S, s' \rangle \Rightarrow^{k_2} s''$ for some
intermediate state $s'$.

\subsubsection{The Semantic Function}

We can now condense the meaning of statements into a partial
function from \textbf{State} to \textbf{State}. We define the semantic
function as follows: \begin{gather*}
  \mathcal{S}: \textbf{Stm} \to (\textbf{State} \hookrightarrow \textbf{State}).
\end{gather*} Thus for a given statement $S$, we have that: \begin{align*}
  &\mathcal{S}(S) : \textbf{State} \hookrightarrow \textbf{State} \\
  s &\mapsto \begin{cases}
    s' & \text{if } \langle S, s \rangle \Rightarrow^* s' \\
    \text{undefined} & \text{otherwise}.
  \end{cases}
\end{align*} We that this function is partial because some statements
may never terminate. Thus giving an indeterminate answer.
\\[\baselineskip]
As there is more than one semantic function (for our different types
of semantics) we denote this function as $\mathcal{S}_{sos}$.

\subsection{Semantic Equivalence}

For every statement $S$ of \textbf{While}, we have that: \begin{gather*}
  \mathcal{S}_{ns}(S) = \mathcal{S}_{sos}(S).
\end{gather*} Similarly, we have that if a statement terminates to a state
for one type of semantics, it will terminate in the same state for the other.

\section{The Abstract Machine}

\subsection{Configurations of the Abstract Machine}

We have that the configurations of the abstract machine are of the 
form: \begin{gather*}
  \langle c, e, s \rangle,
\end{gather*} where $c$ is the code being executed, $e$ is the
evaluation stack, and $s$ is the storage. We use $\varepsilon$ to 
denote an empty stack or code.

\subsubsection{Code}

The code being executed is simply an instruction defined as follows:
\begin{align*}
  c :&= \text{empty} \, | \, \text{inst};c \\
  \text{inst} :&= \text{PUSH}-n \, | \, \text{ADD} \, | \, \text{MULT} \, | \, \text{SUB} \\
  &| \, \text{TRUE} \, | \, \text{FALSE} \, | \, \text{EQ} \, | \, \text{LE} \, | \, \text{AND} \, | \, \text{NEG} \\
  &| \, \text{FETCH}-x \, | \, \text{STORE}-x \, | \, \text{NOOP} \\
  &| \, \text{BRANCH}(c, c) \, | \, \text{LOOP}(c, c). \\
\end{align*}

\subsubsection{Evaluation Stack}

The evaluation stack is an stack of elements in $\mathbb{Z}$ or $T$.

\subsubsection{Storage}

For the sake of simplicity, the storage is essentially a state.

\subsubsection{Terminal States}

A configuration is terminal if the code is empty.

\newpage

\subsection{Operational Semantics for the Abstract Machine}

The table below lays out the operational semantics for the abstract machine.
\begin{center}
  \renewcommand{\arraystretch}{1.6}
  \begin{tabular}{ l c l l }
    \hline \multicolumn{4}{c}{Memory Management} \\ \hline
    $\langle$ PUSH-$n:c, e, s$             $\rangle$ & $\triangleright$ & $\langle c, \mathcal{N}(n):e, s \rangle$ & \\
    $\langle$ FETCH-$x:c, e, s$            $\rangle$ & $\triangleright$ & $\langle c, s(x):e, s \rangle$ & \\
    $\langle$ STORE-$x:c, z:e, s$          $\rangle$ & $\triangleright$ & $\langle c, e, s[x \mapsto z] \rangle$ & if $z$ is in $\mathbb{Z}$ \\
    \hline \multicolumn{4}{c}{Arithmetic Operators} \\ \hline
    $\langle$ ADD$:c, z_1:z_2:e, s$        $\rangle$ & $\triangleright$ & $\langle c, (z_1 + z_2):e, s \rangle$ & if $z_1, z_2$ are in $\mathbb{Z}$ \\
    $\langle$ MULT$:c, z_1:z_2:e, s$       $\rangle$ & $\triangleright$ & $\langle c, (z_1 \star z_2):e, s \rangle$ & if $z_1, z_2$ are in $\mathbb{Z}$ \\
    $\langle$ SUB$:c, z_1:z_2:e, s$        $\rangle$ & $\triangleright$ & $\langle c, (z_1 - z_2):e, s \rangle$ & if $z_1, z_2$ are in $\mathbb{Z}$ \\
    \hline \multicolumn{4}{c}{Boolean Operators} \\ \hline
    $\langle$ TRUE$:c, e, s$               $\rangle$ & $\triangleright$ & $\langle c, \text{tt}:e, s \rangle$ & \\
    $\langle$ FALSE$:c, e, s$              $\rangle$ & $\triangleright$ & $\langle c, \text{ff}:e, s \rangle$ & \\
    $\langle$ EQ$:c, z_1:z_2:e, s$         $\rangle$ & $\triangleright$ & $\langle c, (z_1 == z_2):e, s \rangle$ & if $z_1, z_2$ are in $\mathbb{Z}$ \\
    $\langle$ LEQ$:c, z_1:z_2:e, s$        $\rangle$ & $\triangleright$ & $\langle c, (z_1 \leq z_2):e, s \rangle$ & if $z_1, z_2$ are in $\mathbb{Z}$ \\
   
    \hdashline

    \multirow{2}{*}{
    $\langle$ AND$:c, t_1:t_2:e, s$ $\rangle$
    } & $\triangleright$ & $\langle c, \text{tt}:e, s \rangle$ & if $t_1 == $ tt, $t_2 == $ tt \\
    & $\triangleright$ & $\langle c, \text{ff}:e, s \rangle$ & otherwise \\
    
    \hdashline

    \multirow{2}{*}{
    $\langle$ NEG$:c, t:e, s$ $\rangle$ 
    } & $\triangleright$ & $\langle c, \text{tt}:e, s \rangle$ & if $t$ == ff \\
    & $\triangleright$ & $\langle c, \text{ff}:e, s \rangle$ & if $t$ == tt \\

    \hline \multicolumn{4}{c}{Control Flow} \\ \hline
    $\langle$ NOOP$:c, e, s$ $\rangle$ & $\triangleright$ & $\langle c, e, s \rangle$ & \\
    
    \hdashline

    \multirow{2}{*}{
    $\langle$ BRANCH$(c_1, c_2):c, t:e, s$ $\rangle$ 
    } & $\triangleright$ & $\langle c_1, e, s \rangle$ & if $t ==$ tt \\
    & $\triangleright$ & $\langle c_2, e, s \rangle$ & otherwise \\
    
    \hdashline

    $\langle$ LOOP$(c_1, c_2):c, e, s$ $\rangle$ & $\triangleright$ & 
    \multicolumn{2}{l}{
    $\langle c_1:$BRANCH($c_2:$LOOP($c_1, c_2$), NOOP)$:c, e, s \rangle$
    } \\
  \end{tabular}
\end{center}

\subsubsection{Computation Sequences}

Corresponding to the derivation sequences of structural operational semantics,
we can also define a computation sequence of the abstract machine. For a 
sequence of instructions $c$ and some storage $s$, the length of such a sequence 
is either: \begin{itemize}
  \item \textbf{Finite}: $\gamma_0, \gamma_1, \gamma_2, \ldots, \gamma_k$
  for some $k$ in $\mathbb{Z}_{\geq 0}$ where each $i$ in $\{0, 1, \ldots, k - 1\}$ satisfies
  $\gamma_0 = \langle c, \varepsilon, s \rangle$, $\gamma_i \triangleright \gamma_{i + 1}$ where
  there is no $\gamma$ such that $\gamma_k \triangleright \gamma$
  \item \textbf{Infinite}: $(\gamma_k)_{k \geq 0}$ where 
  for each $i$ in $\mathbb{Z}_{\geq 0}$ satisfies 
  $\gamma_0 = \langle c, \varepsilon, s \rangle$, $\gamma_i \triangleright \gamma_{i + 1}$.
\end{itemize} We have that the evaluation stack $e$ is always empty
initially. We say the computation sequence is terminating if it's finite
and looping if it's infinite. Terminating sequences lead to terminal or stuck
configurations.
\\[\baselineskip]
The semantics of the abstract machine are deterministic as defined
in the table above, meaning for all
computation sequences $\gamma, \gamma_1, \gamma_2$: \begin{gather*}
  \begin{rcases*}
    \gamma_1 \triangleright \gamma \, \\
    \gamma_2 \triangleright \gamma \,
  \end{rcases*} \Rightarrow \gamma_1 = \gamma_2.
\end{gather*}

\subsection{The Execution Function}

Similarly to the semantic function for our types of semantics,
we define a function for the execution of abstract machine code, 
$\mathcal{M}$: \begin{align*}
  \mathcal{M} &: \textbf{Code} \to (\textbf{State} \hookrightarrow \textbf{State}) \\
  \mathcal{M}(c)(s) &= \begin{cases}
    s' & \text{if } \langle c, \varepsilon, s \rangle \triangleright^* \langle \varepsilon, e, s' \rangle\\
    \text{undefined} & \text{otherwise.}
  \end{cases}
\end{align*}

\vfill

\subsection{Code Generation}

We define functions for generating code for the abstract machine from
expressions and statements.

\subsubsection{Arithmetic expressions}

This code generation function has the form: \begin{gather*}
  \mathcal{CA} : \textbf{Aexp} \to \textbf{Code}.
\end{gather*} The function is defined as follows: \begin{align*}
  \mathcal{CA}(n) &= \text{PUSH-}n\\
  \mathcal{CA}(x) &= \text{FETCH-}x\\
  \mathcal{CA}(a_1 + a_2) &= \mathcal{CA}(a_2):\mathcal{CA}(a_1):\text{ADD}\\
  \mathcal{CA}(a_1 - a_2) &= \mathcal{CA}(a_2):\mathcal{CA}(a_1):\text{SUB}\\
  \mathcal{CA}(a_1 \star a_2) &= \mathcal{CA}(a_2):\mathcal{CA}(a_1):\text{MULT}.\\
\end{align*}

\subsubsection{Boolean expressions}

This code generation function has the form: \begin{gather*}
  \mathcal{CB} : \textbf{Bexp} \to \textbf{Code}.
\end{gather*} The function is defined as follows: \begin{align*}
  \mathcal{CB}(\texttt{true}) &= \text{TRUE}\\
  \mathcal{CB}(\texttt{false}) &= \text{FALSE}\\
  \mathcal{CB}(a_1 == a_2) &= \mathcal{CA}(a_2):\mathcal{CA}(a_1):\text{EQ}\\
  \mathcal{CB}(a_1 \leq a_2) &= \mathcal{CA}(a_2):\mathcal{CA}(a_1):\text{LEQ}\\
  \mathcal{CB}(\neg b) &= \mathcal{CB}(b):\text{NEG}\\
  \mathcal{CB}(b_1 \land b_2) &= \mathcal{CB}(b_2):\mathcal{CB}(b_1):\text{AND}.\\
\end{align*}

\subsubsection{Statements}

This code generation function has the form: \begin{gather*}
  \mathcal{CS} : \textbf{Stm} \to \textbf{Code}.
\end{gather*} The function is defined as follows: \begin{align*}
  \mathcal{CS}(x = a) &= \mathcal{CA}(a):\text{STORE-}x \\
  \mathcal{CS}(\texttt{skip}) &= \text{NOOP} \\
  \mathcal{CS}(S_1:S_2) &= \mathcal{CS}(S_1):\mathcal{CS}(S_2) \\
  \mathcal{CS}(
    \texttt{if } b \texttt{ then } S_1 \texttt{ else } S_2
  ) &= \mathcal{CB}(b):\text{BRANCH}(\mathcal{CS}(S_1), \mathcal{CS}(S_2)) \\
  \mathcal{CS}(
    \texttt{while } b \texttt{ do } S
  ) &= \text{LOOP}(\mathcal{CB}(b), \mathcal{CS}(s)).
\end{align*}

\subsection{The Semantic Function}

We define the semantic function as follows: \begin{gather*}
  \mathcal{S}: \textbf{Stm} \to (\textbf{State} \hookrightarrow \textbf{State}).
\end{gather*} Thus for a given statement $S$, we have that: \begin{gather*}
  \mathcal{S}(S) = (\mathcal{M} \circ \mathcal{CS})(S).
\end{gather*} We that this function is partial because some statements
may never terminate. Thus giving an indeterminate answer.
\\[\baselineskip]
As there is more than one semantic function (for our different types
of semantics) we denote this function as $\mathcal{S}_{am}$.

\subsection{Correctness}

\subsubsection{Arithmetic expressions}

We have that for all arithmetic expressions $a$: \begin{gather*}
  \langle \mathcal{CA}(a), \varepsilon, s \rangle 
  \triangleright^*
  \langle \varepsilon, \mathcal{A}(a)(s), s \rangle,
\end{gather*} and all intermediary states have non-empty stacks.

\subsubsection{Boolean expressions}

We have that for all boolean expressions $b$: \begin{gather*}
  \langle \mathcal{CB}(b), \varepsilon, s \rangle 
  \triangleright^*
  \langle \varepsilon, \mathcal{B}(b)(s), s \rangle,
\end{gather*} and all intermediary states have non-empty stacks.

\subsubsection{Statements}

We have that for all statements $S$: \begin{gather*}
  S_{ns}(S) = S_{sos}(S) = S_{am}(S).
\end{gather*} Also, for all states $s$, we have that: \begin{gather*}
  \begin{rcases*}
    \langle S, s \rangle \to s' \\
    \qquad \text{or} \\
    \langle S, s \rangle \Rightarrow^* s'
  \end{rcases*} \Rightarrow
  \langle \mathcal{CS}(S), \varepsilon, s \rangle \triangleright^* 
  \langle \varepsilon, \varepsilon, s' \rangle 
\end{gather*}

\section{Denotational Semantics}

\subsection{Partial Order}

\subsubsection{Weak partial order}

A weak partial order on $X$ with $a, b, c$ in $X$ 
has the following properties: \begin{itemize}
  \item reflexive ($a \leq a$)
  \item transitive ($a \leq b$, $b \leq c \Rightarrow a \leq c$)
  \item antisymmetric ($a \leq b, b \leq a \Rightarrow a = b$)
\end{itemize}

\subsubsection{Strong partial order}

A strong partial order on $X$ with $a, b, c$ in $X$ 
has the following properties: \begin{itemize}
  \item irreflexive ($a \leq a$ for no $a$)
  \item transitive ($a \leq b$, $b \leq c \Rightarrow a \leq c$)
  \item antisymmetric ($a \leq b, b \leq a \Rightarrow a = b$)
\end{itemize}

\subsubsection{Total partial order}

A total partial order on $X$ with $a, b, c$ in $X$ 
has the following properties: \begin{itemize}
  \item connex ($a \leq b$ or $b \leq a$)
  \item reflexive ($a \leq a$)
  \item transitive ($a \leq b$, $b \leq c \Rightarrow a \leq c$)
  \item antisymmetric ($a \leq b, b \leq a \Rightarrow a = b$)
\end{itemize}

\subsection{Partial-Order Sets}

For a partial order $\sqsubseteq$ on a set $D$, we have that
$(\sqsubseteq, D)$ is a partial order set (PO-set).

\subsubsection{Chains}

For a PO-set $(\sqsubseteq, D)$, for $X \subseteq D$, we say that
$X$ is a chain if and only if for all $x_1, x_2$ in $X$: \begin{gather*}
  x_1 \sqsubseteq x_2 \text{ or } x_2 \sqsubseteq x_1,
\end{gather*} meaning $X$ is totally ordered. 

\subsubsection{Least upper bounds}

For a PO-set $(\sqsubseteq, D)$, the least upper bound 
$x$ of $X \subseteq D$ is denoted by $x = \sqcup \, X$. 
\\[\baselineskip]
If such a bound exists for all subsets $X$ that are chains, 
$(\sqsubseteq, D)$ is a \textit{chain complete} PO-set.
\\[\baselineskip]
If such a bound exists for all subsets $X$, $(\sqsubseteq, D)$ 
is a \textit{complete lattice}.

\subsubsection{Lifted Partial-Order sets}

A PO-set is 'lifted' if an artificial bottom element $\bot$
is added to the set.

\subsubsection{A partial order on state transformers}

We have the following PO-set $(\sqsubseteq, T)$ where: \begin{gather*}
  T = \{f \text{ where } f : \textbf{State} \hookrightarrow \textbf{State}\},
\end{gather*} and for $f, g$ in $T$: \begin{gather*}
  f \sqsubseteq g  \\ 
  \Longleftrightarrow \\
  f s = s' \Rightarrow g s = s' \text{ for all states } s. 
\end{gather*} This is a \textbf{weak} partial order on $T$, with
the least element being $0$ in $T$ undefined for all inputs.

\newpage

\subsubsection{Fixed point theorem}

For $f : X \to X$ a continuous function on a chain-complete partial order
$(\sqsubseteq, X)$ with a least element $\bot$, we have that: \begin{gather*}
  \texttt{FIX } f = \sqcup \, \{f^n(\bot) : n \in \mathbb{Z}_{\geq 0}\},
\end{gather*} exists and is the least fixed point of $f$. For clarity: 
\begin{gather*}
  f^0 = \texttt{id} \qquad f^n = f \circ f^{n - 1},
\end{gather*} where $n$ is in $\mathbb{Z}_{\geq 0}$.

\subsubsection{The conditional function}

We define the type of \texttt{cond} as follows: \begin{gather*}
  \texttt{cond} : 
  (\textbf{State} \to \textbf{T}) \times
  (\textbf{State} \hookrightarrow \textbf{State}) \times
  (\textbf{State} \hookrightarrow \textbf{State}) \to
  (\textbf{State} \hookrightarrow \textbf{State}),
\end{gather*} with definition: \begin{gather*}
  \texttt{cond}(p, f_1, f_2)s = \begin{cases}
    f_1(s) & \text{if } p(s) == \textbf{tt} \\
    f_2(s) & \text{otherwise.} \\
  \end{cases}
\end{gather*}

\subsubsection{The fixed point function}

We define the type of \texttt{FIX} as follows: \begin{gather*}
  \texttt{FIX} : 
  (\textbf{State} \hookrightarrow \textbf{State}) \to
  (\textbf{State} \hookrightarrow \textbf{State}) \to
  (\textbf{State} \hookrightarrow \textbf{State}),
\end{gather*} where \texttt{FIX}$(F)$ returns the least fixed 'point'
(or rather function) of $F$ ($f$ in Im($F$) such that $F(f) = f$). 
Smallest in this case is the 'most undefined' function.

\vfill

\subsubsection{Breaking down a Fibonacci definition using \texttt{FIX}}

Consider the following definition:

\begin{lstlisting}
fib :: Int -> Int
fib = fix F where
  F :: (Int -> Int) -> (Int -> Int)
  F f n
    | (n == 0) || (n == 1) = 1
    | otherwise            = (f (n - 1)) + (f (n - 2))
\end{lstlisting}

\newpage

So, if we want to calculate \texttt{fib 4} we get: \begin{center}
  \begin{tabular}{ l l }
    \begin{lstlisting}
      fib 4    = fix F 4
               = F (fix F) 4
               = (fix F 3) + (fix F 2)
      
      fix F 3 = F (fix F) 3
               = (fix F 2) + (fix F 1)
      
      fix F 2 = F (fix F) 2
               = (fix F 1) + (fix F 0)
      
      fix F 1 = F (fix F) 1
               = 1
      
      fix F 0 = F (fix F) 0
               = 1
      \end{lstlisting}
      &
      \begin{lstlisting}
        fix F 2 = F (fix F) 2
                 = (fix F 1) + (fix F 0)
                 = 1 + 1
                 = 2
        
        fix F 3 = F (fix F) 3
                 = (fix F 2) + (fix F 1)
                 = 2 + 1
                 = 3
        
        fib 4    = fix F 4
                 = F (fix F) 4
                 = (fix F 3) + (fix F 2)
                 = 3 + 2
                 = 5
      \end{lstlisting}
  \end{tabular}
\end{center}

\subsection{Direct Style}

\subsubsection{The Semantic Function} 

We define the semantic function as follows: \begin{gather*}
  \mathcal{S}: \textbf{Stm} \to (\textbf{State} \hookrightarrow \textbf{State}).
\end{gather*} We that this function is partial because some statements
may never terminate. We have the following: \begin{align*}
  \mathcal{S}(x = a)(s) &= s[x \mapsto \mathcal{A}(a)(s)] \\
  \mathcal{S}(\texttt{skip}) &= \texttt{id} \\
  \mathcal{S}(S_1 ; S_2) &= \mathcal{S}(S_2) \circ \mathcal{S}(S_1) \\
  \mathcal{S}(\texttt{if } b \texttt{ then } S_1 \texttt{ else } S_2)
  &= \texttt{cond}(\mathcal{B}(b), \mathcal{S}(S_1), \mathcal{S}(S_2)) \\
  \mathcal{S}(\texttt{while } b \texttt{ do } S)
  &= \texttt{FIX } F \text{ (where } F(g) 
  := \texttt{cond}(\mathcal{B}(b), g \circ \mathcal{S}(S), \texttt{id})).
\end{align*} 
As there is more than one semantic function (for our different types
of semantics) we denote this function as $\mathcal{S}_{ds}$.

\subsection{Continuation Style}

A continuation describes the effect of executing the remainder of the
program denoted as \textbf{Cont} and typed as follows: \begin{gather*}
  \textbf{Cont} = \textbf{State} \hookrightarrow \textbf{State}.
\end{gather*} For a sequence of statements
$\{S_1, S_2, \ldots, S_k, \ldots, S_{n - 1}, S_n\}$
we have that the continuation $c$ from $n$ to $k$ can be extended
to $c'$ the continuation from $n$ to $k - 1$ illustrated here: \begin{gather*}
  S_1, S_2, \ldots, 
  \underbrace{S_{k - 1}, \overbrace{S_k, \ldots, S_{n - 1}, S_n}^c}_{c'}.
\end{gather*}

\subsubsection{The Semantic Function on \textbf{While}} 

We define the semantic function as follows: \begin{gather*}
  \mathcal{S}: \textbf{Stm} \to (\textbf{Cont} \hookrightarrow \textbf{Cont}).
\end{gather*} We that this function is partial because some statements
may never terminate. We have the following: \begin{align*}
  \mathcal{S}(x = a)(c)(s) &= c(s[x \mapsto \mathcal{A}(a)(s)]) \\
  \mathcal{S}(\texttt{skip})(c)(s) &= c(s) \\
  \mathcal{S}(S_1 ; S_2) &= \mathcal{S}(S_1) \circ \mathcal{S}(S_2) \\
  \mathcal{S}(\texttt{if } b \texttt{ then } S_1 \texttt{ else } S_2)(c)
  &= \texttt{cond}(\mathcal{B}(b), \mathcal{S}(S_1)(c), \mathcal{S}(S_2)(c)) \\
  \mathcal{S}(\texttt{while } b \texttt{ do } S)
  &= \texttt{FIX } F \text{ (where } F(g)(c) 
  := \texttt{cond}(\mathcal{B}(b), \mathcal{S}(S)(g(c)), c)).
\end{align*} 
As there is more than one semantic function (for our different types
of semantics) we denote this function as $\mathcal{S}_{cs}^{\textbf{While}}$.

\subsubsection{The Semantic Function on \textbf{Exc}} 

\paragraph{Exception environments} we define exeception environments
$env_E$ of type \newline 
$\textbf{Env}_E : \textbf{Exception} \to \textbf{Cont}$.
\\[\baselineskip]
We define the semantic function as follows: \begin{gather*}
  \mathcal{S}: \textbf{Stm} \to \textbf{Env}_E 
  \to (\textbf{Cont} \hookrightarrow \textbf{Cont}).
\end{gather*} We that this function is partial because some statements
may never terminate. We have the following: \begin{align*}
  \mathcal{S}(x = a)(env_E)(c)(s) &= c(s[x \mapsto \mathcal{A}(a)(s)]) \\
  \mathcal{S}(\texttt{skip})(env_E)(c)(s) &= c(s) \\
  \mathcal{S}(S_1 ; S_2)(env_E) &= \mathcal{S}(S_1)(env_E) \circ \mathcal{S}(S_2)(env_E) \\
  \mathcal{S}(\texttt{if } b \texttt{ then } S_1 \texttt{ else } S_2)(env_E)(c)
  &= \texttt{cond}(\mathcal{B}(b), \mathcal{S}(S_1)(env_E)(c), \mathcal{S}(S_2)(env_E)(c)) \\
  \mathcal{S}(\texttt{while } b \texttt{ do } S)(env_E)
  &= \texttt{FIX } F \\
  \text{ (where } F(g)(c) &
  := \texttt{cond}(\mathcal{B}(b), \mathcal{S}(S)(env_E)(g(c)), c)) \\
  \mathcal{S}(\texttt{begin } S_1 \texttt{ handle } e: S_2 \texttt{ end}) \\
  (env_E)(c) &= \mathcal{S}(S_1)(env_E[e \mapsto \mathcal{S}(S_2)(env_E)(c)]) c \\
  \mathcal{S}(\texttt{raise } e)(env_E)(c) &= env_E e.
\end{align*} 
As there is more than one semantic function (for our different types
of semantics) we denote this function as $\mathcal{S}_{cs}^{\textbf{Exc}}$.

\end{document}