\section{Finite State Automaton}

\subsection{Deterministic Finite State Automaton}

A deterministic finite state automaton (DFA) is a 5-tuple 
$M = \langle Q, \Sigma, \delta, q_0, F \rangle$
where: \begin{align*}
    Q      &= \text{ any finite set, called the states,} \\
    \Sigma &= \text{ any alphabet,} \\ 
    \delta &\in \{ Q \times \Sigma \to Q \} \text{ is the the transition function,} \\
    q_0    &\in Q \text{ is the initial state,} \\
    F      &\subseteq Q \text{ is the set of accept states.}
\end{align*} We say that $M$ accepts a word $w$ in $\Sigma$
if there is a sequence of states $r_0, \ldots, r_n$ in $Q$
satisfying: \begin{itemize}
    \item $r_0 = q_0$,
    \item $\delta(r_i, w_{i + 1}) = r_{i + 1}$,
    \item $r_n$ is in $F$.
\end{itemize}

\subsubsection{Product Automaton}

For the two DFA: \begin{align*}
    M_1 = \langle Q_1, \Sigma, \delta_1, q_1, F_1 \rangle,
    M_2 = \langle Q_2, \Sigma, \delta_2, q_2, F_2 \rangle,
\end{align*} the product automaton $M$ is: \begin{gather*}
    M = M_1 \times M_2 = \langle Q, \Sigma, \delta, q_0, F \rangle,
\end{gather*} where: \begin{align*}
    Q &= Q_1 \times Q_2 \\
    \delta((p_1, p_2), a) &= (\delta_1(p_1, a), \delta_2(p_2, a)), \\
    q_0 &= (q_1, q_2), \\
    F &= F_1 \times F_2.
\end{align*}

\subsection{Non-deterministic Finite State Automaton}

A non-deterministic finite state automaton (NFA) is identical
to a DFA except our transition function is from 
$Q \times \Sigma_\epsilon \to \mathcal{P}(Q)$ where
$\Sigma_\epsilon$ is an alphabet $\Sigma$ with the empty word
added.
\\[\baselineskip]
Transitioning on the empty word doesn't consume a letter of our
input word and arbitrary choices are made by the automaton when
choices present themselves. We have that a word is accepted
in an NFA if and only if there is at least one computation where 
the word is accepted.
    
\subsection{Languages}

For a DFA $M$, the language set of $M$ denoted by $L(M)$
is the maximal set of words in the alphabet of $M$ such that
for each $w$ in $L(M)$, $M$ accepts $w$. We say $M$ recognises
a language $A$ if $L(M) = A$.

\subsubsection{Regular Languages}

A language is regular if it is recognised by some DFA.

\subsubsection{Operations on Regular Languages}

We can calculate the union and intersection of regular languages
as expected and for two DFA $M_1$ and $M_2$ with languages
$A$ and $B$ (resp.), we have that $A \cap B$ is
recognised by $M_1 \times M_2$ the product automaton.
\\[\baselineskip]
Additionally, we can concatenate two regular languages $A$ and
$B$: \begin{gather*}
    A \circ B = \{xy : x \in A \text{ and } y \in B\},
\end{gather*} and form the Kleene Star: \begin{gather*}
    A^* = \{x_0 \cdots x_k : k \in \mathbb{Z}_{\geq 0}
        \text{ and for each } i \in \{0, 1, \ldots, k\}, 
        x_i \in A\}.
\end{gather*} We have that each of these operations are closed
in the set of regular languages.

\subsection{Regular Expressions}

We have that $R$ is a regular expression over an alphabet
$\Sigma$ if it has one of the following shapes:
\begin{center}
    \begin{tabular}{ c l }
        $\emptyset$ & \\
        $\epsilon$ & \\
        $a$ & for some $a$ in $\Sigma$ \\
        $R_1 \cup R_2$ & for some regular expressions $R_1$ and $R_2$ \\
        $R_1 \circ R_2$ & for some regular expressions $R_1$ and $R_2$ \\
        $R^*$ & for some regular expression $R$ \\
    \end{tabular}
\end{center} The language of regular expressions $R_1$ and $R_2$
can be formed as follows: \begin{align*}
    L(\emptyset) &= \emptyset \\
    L(\epsilon) &= \{\epsilon\} \\
    L(a) &= \{a\} \\
    L(R_1 \cup R_2) &= L(R_1) \cup L(R_2) \\
    L(R_1 \circ R_2) &= L(R_1) \circ L(R_2) \\
    L(R_1^*) &= L(R_1)^*
\end{align*} We have that a language $L$ is regular
if and only if $L = L(R)$ for some regular expression $R$.

\subsection{Epsilon Closure}

For the NFA $M =  \langle Q, \Sigma, \delta, q_0, F \rangle$, 
and $R \subseteq Q$, we define the epsilon closure
of $R$ to be: \begin{gather*}
    E(R) := \left\{
        q \in Q : \bfrac{
        \text{ where there is a series of 
        transitions solely over }
    }{
        \epsilon \text{ from some } r \text{ in } 
        R \text{ to } q
    }\right\}
\end{gather*}

\subsubsection{Simulating NFA with DFA}

We can simulate an arbitrary NFA: \begin{gather*}
    M =  \langle Q, \Sigma, \delta, q_0, F \rangle
\end{gather*}
with a DFA: \begin{gather*}
    M' = \langle Q', \Sigma_\epsilon, \delta', q_0', F' \rangle
\end{gather*} where: \begin{align*}
    Q'   &= \mathcal{P}(Q), \\
    \delta'(q, a) &= \{q : \text{for some }
        r \in R, q \in E(\delta(r, a))
    \} \\
    q_0' &= E(\{q_0\}), \\
    F'   &= \{q' \in Q' : \text{for some } q \in q', q \in F\}.
\end{align*} Now that we have this, we know that languages are
regular if and only if they are accepted by some NFA as
all DFA are NFA and each NFA can be expressed by a DFA.
